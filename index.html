<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>레트로 아케이드 테트리스 (No Sound)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #111;
            --screen-bg: #000;
            --text-color: #eee;
            --accent-color: #fce300;
            --crt-scanline-color: rgba(0, 0, 0, 0.2);
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px 40px;
            box-sizing: border-box;
            user-select: none;
        }

        h1 {
            color: var(--accent-color);
            text-shadow: 3px 3px 0 #ff0000;
            margin: 0 0 14px 0;
            font-size: 2rem;
            text-align: center;
        }

        #game-container {
            position: relative;
            display: flex;
            background-color: var(--screen-bg);
            border: 10px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.1);
            padding: 10px;
            transform: perspective(1000px) rotateX(2deg);
            max-width: 1000px;
            width: 100%;
            justify-content: center;
        }

        #game-container::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(var(--crt-scanline-color) 50%, rgba(0, 0, 0, 0) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* 메인 게임 보드: 내부 논리는 300x600 유지, 화면은 창에 맞게 스케일 */
        #tetris-canvas {
            background-color: #000;
            border: 2px solid #555;
            image-rendering: pixelated;
            /* 뷰포트 비례 크기 - 세로가 가로의 2배 비율 유지 */
            width: min(40vmin, 360px);
            height: calc(min(40vmin, 360px) * 2);
        }

        /* NEXT 미리보기는 너무 크지 않게 */
        #next-canvas {
            background-color: #000;
            border: 2px solid #555;
            image-rendering: pixelated;
            width: 120px;
            height: 120px;
        }

        #info-panel {
            margin-left: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: 150px;
            z-index: 5;
        }

        .info-box {
            margin-bottom: 18px;
        }

        .info-label {
            color: var(--accent-color);
            font-size: 0.75rem;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.1rem;
        }

        #insert-coin-msg {
            margin-top: auto;
            color: red;
            font-size: 0.85rem;
            text-align: center;
            line-height: 1.5;
        }

        .blink { animation: blinker 0.8s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        #overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }

        #controls-info {
            margin-top: 16px;
            font-size: 0.6rem;
            color: #bbb;
            text-align: left; /* 왼쪽 정렬 */
            max-width: 1000px;
            width: 100%;
            line-height: 1.6;
        }

        #controls-info p {
            margin: 3px 0;
        }

        /* 작은 화면(태블릿/모바일)에서 레이아웃 조정 */
        @media (max-width: 768px) {
            #game-container {
                flex-direction: column;
                align-items: center;
                transform: none; /* 기울기 제거해서 화면 낭비 줄이기 */
            }

            #info-panel {
                margin-left: 0;
                margin-top: 12px;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
                width: 100%;
            }

            .info-box {
                margin-bottom: 10px;
                text-align: center;
            }

            #insert-coin-msg {
                margin-top: 10px;
                width: 100%;
            }

            #tetris-canvas {
                width: 60vmin;
                height: calc(60vmin * 2);
            }

            #controls-info {
                font-size: 0.55rem;
            }
        }
    </style>
</head>
<body>

    <h1>TETRIS</h1>

    <div id="game-container">
        <canvas id="tetris-canvas" width="300" height="600"></canvas>
        
        <div id="info-panel">
            <div class="info-box">
                <div class="info-label">SCORE</div>
                <div id="score" class="info-value">0</div>
            </div>
            <div class="info-box">
                <div class="info-label">LEVEL</div>
                <div id="level" class="info-value">1</div>
            </div>
            <div class="info-box">
                <div class="info-label">NEXT</div>
                <canvas id="next-canvas" width="120" height="120"></canvas>
            </div>
            
             <div id="insert-coin-msg" class="blink">
                INSERT COIN<br>
                <span style="font-size:0.6rem; color:white;">[SHIFT]</span>
            </div>
        </div>
        
        <div id="overlay-screen">
            <div id="overlay-title" style="font-size: 1.5rem; margin-bottom: 20px; color: var(--accent-color);">PRESS SHIFT<br>TO START</div>
            <div id="overlay-sub" style="font-size: 0.7rem; color: #fff;">1 COIN = 1 PLAY</div>
        </div>
    </div>

    <div id="controls-info">
        <p>[SHIFT]: 동전 넣기 / 게임 시작</p>
        <p>← → : 이동 | ↑ : 회전</p>
        <p>↓ : 천천히 | SPACE : 한방에(쾅!)</p>
    </div>

    <script>
        // --- 기본 설정 ---
        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');
        
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const overlayScreen = document.getElementById('overlay-screen');
        const overlayTitle = document.getElementById('overlay-title');
        const overlaySub = document.getElementById('overlay-sub');
        const insertCoinMsg = document.getElementById('insert-coin-msg');

        const ROW = 20;
        const COL = 10;
        const SQ = 30;
        const VACANT = "BLACK";

        // 테트로미노 정의
        const PIECES = [
            [ [[1,1,0],[0,1,1],[0,0,0]], "#FF0000" ], // Z
            [ [[0,1,1],[1,1,0],[0,0,0]], "#00FF00" ], // S
            [ [[0,1,0],[1,1,1],[0,0,0]], "#800080" ], // T
            [ [[1,1],[1,1]],             "#FFFF00" ], // O
            [ [[0,0,1],[1,1,1],[0,0,0]], "#FFA500" ], // L
            [ [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], "#00FFFF" ], // I
            [ [[1,0,0],[1,1,1],[0,0,0]], "#0000FF" ]  // J
        ];

        // 게임 상태 변수
        let board = [];
        let score = 0;
        let level = 1;
        let gameOver = false;
        let isGameRunning = false;
        let isPaused = false;      
        let dropStart = Date.now();
        let dropSpeed = 1000;
        let p = null;     
        let nextP = null; 
        let requestAnimationFrameId = null;

        // --- 보드 및 그리기 함수 ---
        function createBoard() {
            for (let r = 0; r < ROW; r++) {
                board[r] = [];
                for (let c = 0; c < COL; c++) {
                    board[r][c] = VACANT;
                }
            }
        }

        function drawSquare(x, y, color, context = ctx) {
            context.fillStyle = color;
            context.fillRect(x * SQ, y * SQ, SQ, SQ);
            if (color !== VACANT) {
                // 이펙트: 흰색이면 빛나게
                if (color === "WHITE") {
                    context.fillStyle = "#FFFFFF";
                    context.fillRect(x * SQ, y * SQ, SQ, SQ);
                    context.shadowBlur = 15;
                    context.shadowColor = "white";
                } else {
                    context.shadowBlur = 0;
                    context.lineWidth = 2;
                    context.strokeStyle = "rgba(0,0,0,0.4)";
                    context.strokeRect(x * SQ + 2, y * SQ + 2, SQ - 4, SQ - 4);
                    context.lineWidth = 1;
                    context.strokeStyle = "#eee";
                    context.strokeRect(x * SQ, y * SQ, SQ, SQ);
                }
            } else {
                 context.shadowBlur = 0;
                 context.strokeStyle = "#222";
                 context.strokeRect(x * SQ, y * SQ, SQ, SQ);
            }
            context.shadowBlur = 0; 
        }

        function drawBoard() {
            for (let r = 0; r < ROW; r++) {
                for (let c = 0; c < COL; c++) {
                    drawSquare(c, r, board[r][c]);
                }
            }
        }

        function drawNextPiece() {
            if(!nextP) return;
            nextCtx.fillStyle = VACANT;
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            let offsetX = (nextCanvas.width / SQ - nextP.activeTetromino[0].length) / 2;
            let offsetY = (nextCanvas.height / SQ - nextP.activeTetromino.length) / 2;
            for (let r = 0; r < nextP.activeTetromino.length; r++) {
                for (let c = 0; c < nextP.activeTetromino.length; c++) {
                    if (nextP.activeTetromino[r][c]) {
                        drawSquare(c + offsetX, r + offsetY, nextP.color, nextCtx);
                    }
                }
            }
        }

        // --- 블록 클래스 ---
        class Piece {
            constructor(tetromino, color) {
                this.tetromino = tetromino;
                this.color = color;
                this.activeTetromino = this.tetromino;
                this.x = Math.floor(COL / 2) - Math.floor(this.activeTetromino[0].length / 2);
                this.y = -2; 
            }

            draw() {
                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        if (this.activeTetromino[r][c]) {
                            drawSquare(this.x + c, this.y + r, this.color);
                        }
                    }
                }
            }

            moveDown() {
                if (!this.collision(0, 1, this.activeTetromino)) {
                    this.y++;
                } else {
                    lockPiece(); 
                }
            }
            
            moveRight() { if (!this.collision(1, 0, this.activeTetromino)) this.x++; }
            moveLeft() { if (!this.collision(-1, 0, this.activeTetromino)) this.x--; }
            rotate() {
                let nextPattern = this.activeTetromino[0].map((val, index) => this.activeTetromino.map(row => row[index]).reverse());
                if (this.collision(0, 0, nextPattern)) {
                    if(!this.collision(1, 0, nextPattern)) this.x +=1;
                    else if(!this.collision(-1, 0, nextPattern)) this.x -=1;
                    else return;
                }
                this.activeTetromino = nextPattern;
            }

            collision(x, y, piece) {
                for (let r = 0; r < piece.length; r++) {
                    for (let c = 0; c < piece.length; c++) {
                        if (!piece[r][c]) continue;
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
                        if (newX < 0 || newX >= COL || newY >= ROW) return true;
                        if (newY < 0) continue;
                        if (board[newY][newX] !== VACANT) return true;
                    }
                }
                return false;
            }
        }

        function randomPiece() {
            let r = Math.floor(Math.random() * PIECES.length);
            return new Piece(PIECES[r][0], PIECES[r][1]);
        }

        // --- 게임 로직 함수 ---
        function lockPiece() {
            for (let r = 0; r < p.activeTetromino.length; r++) {
                for (let c = 0; c < p.activeTetromino.length; c++) {
                    if (!p.activeTetromino[r][c]) continue;
                    if (p.y + r < 0) { // 천장 충돌
                        endGame();
                        return;
                    }
                    board[p.y + r][p.x + c] = p.color;
                }
            }

            let fullRows = [];
            for (let r = 0; r < ROW; r++) {
                let isRowFull = true;
                for (let c = 0; c < COL; c++) {
                    if (board[r][c] === VACANT) { isRowFull = false; break; }
                }
                if (isRowFull) fullRows.push(r);
            }

            if (fullRows.length > 0) {
                // 이펙트 시작 (소리 없음)
                isPaused = true; 
                
                // 1. 하얗게 빛나기
                fullRows.forEach(r => {
                    for(let c=0; c<COL; c++) board[r][c] = "WHITE";
                });
                drawBoard();

                // 2. 0.2초 후 삭제
                setTimeout(() => {
                    fullRows.forEach(r => {
                        removeRow(r); 
                    });
                    
                    score += 100 * fullRows.length * level;
                    scoreElement.innerHTML = score;
                    if(score >= level * 500) {
                        level++;
                        levelElement.innerHTML = level;
                        dropSpeed = Math.max(100, dropSpeed - 100);
                    }

                    isPaused = false;
                    spawnNext();
                }, 200);
            } else {
                spawnNext();
            }
        }

        function removeRow(rowToRemove) {
            for (let r = rowToRemove; r > 0; r--) {
                for (let c = 0; c < COL; c++) {
                    board[r][c] = board[r - 1][c];
                }
            }
            for (let c = 0; c < COL; c++) {
                board[0][c] = VACANT;
            }
        }

        function spawnNext() {
            if (!isGameRunning) return;
            p = nextP;
            nextP = randomPiece();
            drawNextPiece();
            if(p.collision(0,0,p.activeTetromino)) {
                endGame();
            }
        }

        function endGame() {
            gameOver = true;
            isGameRunning = false;
            overlayTitle.innerHTML = "GAME OVER";
            overlayTitle.style.color = "red";
            overlaySub.innerHTML = "PRESS [SHIFT] TO RESTART";
            overlayScreen.style.display = 'flex';
            insertCoinMsg.innerHTML = "INSERT COIN";
            insertCoinMsg.classList.add('blink');
            insertCoinMsg.style.color = "red";
        }

        // --- 메인 컨트롤 ---
        function startGame() {
            // UI 리셋
            overlayScreen.style.display = 'none';
            insertCoinMsg.innerHTML = "CREDIT 1";
            insertCoinMsg.classList.remove('blink');
            insertCoinMsg.style.color = "var(--accent-color)";

            // 변수 리셋
            gameOver = false;
            isGameRunning = true;
            isPaused = false;
            score = 0;
            level = 1;
            dropSpeed = 1000;
            scoreElement.innerHTML = score;
            levelElement.innerHTML = level;
            
            createBoard();
            p = randomPiece();
            nextP = randomPiece();
            drawNextPiece();
            
            dropStart = Date.now();
            if(requestAnimationFrameId) cancelAnimationFrame(requestAnimationFrameId);
            animate();
        }

        function animate() {
            if (!isGameRunning) return;

            if (!isPaused) {
                let now = Date.now();
                if (now - dropStart > dropSpeed) {
                    if (p) p.moveDown();
                    dropStart = Date.now();
                }
            }

            drawBoard();
            if (p && !isPaused) p.draw(); 

            requestAnimationFrameId = requestAnimationFrame(animate);
        }

        // 키보드 입력
        document.addEventListener("keydown", function(event) {
            if (event.keyCode === 16) { // SHIFT
                if (!isGameRunning) {
                    startGame();
                }
                return;
            }

            if (!isGameRunning || isPaused || !p) return;
            
            switch(event.keyCode) {
                case 37: p.moveLeft(); break;
                case 38: p.rotate(); break;
                case 39: p.moveRight(); break;
                case 40: p.moveDown(); dropStart = Date.now(); break; 
                case 32: // Spacebar
                    while(!p.collision(0, 1, p.activeTetromino)) {
                         p.y++;
                    }
                    lockPiece();
                    dropStart = Date.now();
                    drawBoard();
                    if(p && !isPaused) p.draw();
                    break;
            }
        });

        createBoard();
        drawBoard();
    </script>
</body>
</html>
